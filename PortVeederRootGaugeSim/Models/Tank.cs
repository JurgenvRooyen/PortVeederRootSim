using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Dynamic;
using System.Net.Http.Headers;
using System.Text;

namespace PortVeederRootGaugeSim
{
    class Tank
    {
        // Tank attributes
        public int TankId { get; set; }
        public double TankLength { get; set; }
        public double TankDiameter { get; set; }
        public double ProductLevel { get; set; }
        public double WaterLevel { get; set; }
        public int ProductTemerature { get; set; }
        public List<TankDrop> TankDrops { get; set; }

        public const double ThermalExpansionCoefficient = 0.0018;

        // Alarm attributes
        public double FullVolume;
        
        public double MaxSafeWorkingCapacity { get; set; }
        public double OverFillLimit { get; set; }
        public double HighProductAlarmLevel { get; set; }
        public double DeliveryNeededWarningLevel { get; set; }
        public double LowProductAlarmLevel { get; set; }
        public double HighWaterAlarmLevel { get; set; }
        public double HighWaterWarningLevel { get; set; }





        public Tank(int tankId, double tankLength, double tankDiameter, double productLevel, double waterLevel, int productTemerature, List<TankDrop> tankDrops)
        {
            TankId = tankId;
            TankLength = tankLength;
            TankDiameter = tankDiameter;
            ProductLevel = productLevel;
            WaterLevel = waterLevel;
            ProductTemerature = productTemerature;
            TankDrops = tankDrops;

            FullVolume = LevelToVolume(tankLength);

            // Alarm attributes are generated by default which can edit by get and set
            MaxSafeWorkingCapacity      = 0.95 * TankLength;
            OverFillLimit               = 0.90 * TankLength;
            HighProductAlarmLevel       = 0.80 * TankLength;
            DeliveryNeededWarningLevel  = 0.30 * TankLength;
            LowProductAlarmLevel        = 0.20 * TankLength;
            HighWaterAlarmLevel         = 0.10 * TankLength;
            HighWaterWarningLevel       = 0.05 * TankLength;

        }

        public Tank()
        {
        }

        // Add tanl drops and give alarms when needed
        public Boolean AddTankDropAndFeedBack(TankDrop tp)
        {
          
            double PotentialProductLevel = GetPotentialProductLevel();


            if (VolumeToLevel(GetGrossObservedVolume()) + PotentialProductLevel + VolumeToLevel(tp.Volume)  > MaxSafeWorkingCapacity)
            {
                return false;
            }

            TankDrops.Add(tp);
            return true;
        }



        // need timer inside the class and change the way to refresh window
        public Boolean TankDroppingPerSecond() 
        {
            for (int i = 0; i < TankDrops.Count; i++) 
            {
                if (TankDrops[i].Dropped == false) 
                {
                    double IncreasdVolume = TankDrops[i].DropingTankPerSecond();
                    ProductLevel += VolumeToLevel(IncreasdVolume);
                    return true;
                }
            }
            return false;
        }

        // need timer inside the class and change the way to refresh window
        public Boolean TankLeakingPerSecond() 
        {
            if (ProductLevel > VolumeToLevel(0.005 * FullVolume)) 
            {
                ProductLevel -= VolumeToLevel(0.005 * FullVolume);
                return true;
            }
            ProductLevel = 0;
            return false;
        }



        public double GetPotentialProductLevel()
        {
            double PotentialVolume = 0;

            for (int i = 0; i < TankDrops.Count; i++)
            {
                PotentialVolume += TankDrops[i].Volume;
            }

            double PotentialProductLevel = VolumeToLevel(PotentialVolume);

            return PotentialProductLevel;
        }

        public double GetGrossObservedVolume() 
        {
            return LevelToVolume(ProductLevel) + LevelToVolume(WaterLevel);
        }

        public double GetGrossStandardVolume()
        {
            double tempDelta = ProductTemerature - 15;
            return LevelToVolume(ProductLevel) * (1 - ThermalExpansionCoefficient * tempDelta);
        }

        public double GetUllage() 
        {
            return LevelToVolume(MaxSafeWorkingCapacity - ProductLevel - WaterLevel);
        }

        private double VolumeToLevel(double v) 
        {
           double l =  v/ (Math.PI * Math.Pow(TankDiameter / 2, 2));
           return l;
        }

        private double LevelToVolume(double l)
        {
            double v = l * (Math.PI * Math.Pow(TankDiameter / 2, 2));
            return v;
        }



     


        public void Connect(Tank t)
        {
            //TODO-Optional
        }

        public override string ToString()
        {
            return $"{{{nameof(TankId)}={TankId.ToString()}, {nameof(TankLength)}={TankLength.ToString()}, {nameof(TankDiameter)}={TankDiameter.ToString()}, {nameof(ProductLevel)}={ProductLevel.ToString()}, {nameof(WaterLevel)}={WaterLevel.ToString()}, {nameof(ProductTemerature)}={ProductTemerature.ToString()}, {nameof(TankDrops)}={TankDrops.Count}, {nameof(MaxSafeWorkingCapacity)}={MaxSafeWorkingCapacity.ToString("0.##")}}}"+ "           Gross Observed Volume=" + GetGrossObservedVolume().ToString("0.##") + "           Gross Standard Volume=" + GetGrossStandardVolume().ToString("0.##") + "        Ullage=" + GetUllage().ToString("0.##");
        }
    }
}
